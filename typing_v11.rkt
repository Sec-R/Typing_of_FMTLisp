#lang racket
(require r5rs)

(define (tagged-list? exp tag) 

  (if (pair? exp) 

      (equal? (car exp) tag)
      false))


(define (variable? exp) (symbol? exp))  

(define (define? exp)  (tagged-list? exp 'define))

(define (define-struct? exp)  (tagged-list? exp 'define-struct))

(define (if? exp)  (tagged-list? exp 'if))

(define (let? exp)  (tagged-list? exp 'let))

(define (cons-exp? exp) (tagged-list? exp 'cons))

(define (list-exp? exp) (tagged-list? exp 'list))

(define (car? exp) (tagged-list? exp 'car))

(define (cdr? exp) (tagged-list? exp 'cdr))

(define (constructor? exp ctx)
  (define (innerloop body new-ctx)
    (cond ((null? body)(if (null? (cadddr new-ctx))
                           #f
                           (innerloop (caddr (cadddr new-ctx)) (cadddr new-ctx))))
          ((equal? (car exp) (car (car body))) #t)
          (else (innerloop (cdr body) new-ctx))))
  (innerloop (caddr ctx) ctx))

(define (primitive? exp) (or (tagged-list? exp '+)
                             (tagged-list? exp '-)
                             (tagged-list? exp '*)
                             (tagged-list? exp '/)
                             (tagged-list? exp '>)
                             (tagged-list? exp '<)
                             (tagged-list? exp '=)
                             (tagged-list? exp 'remainder)))

(define (format? exp) (tagged-list? exp 'format))

(define (cond? exp)  (tagged-list? exp 'cond))

(define (assignment? exp) (tagged-list? exp 'set!))

(define (begin? exp)  (tagged-list? exp 'begin))

(define (not? exp) (tagged-list? exp 'not))

(define (lambda? exp)  (tagged-list? exp 'lambda))

(define (find-first-not- str now)
    (cond((= now (string-length str))#f)
         ((equal? (string-ref str now) #\-) now)
         (else (find-first-not- str (+ now 1)))))

(define (get-something-from-type? exp ctx)
  (if (not (pair? (car exp)))
      (let ((first (find-first-not- (symbol->string (car exp)) 0)))
        (if (and first (> first 0) (> (string-length (symbol->string (car exp))) (+ 4 first)) (equal? (string->symbol(substring (symbol->string (car exp)) first (+ first 5))) '-get- ))
            (if (constructor? (list (string->symbol(substring (symbol->string (car exp)) 0 first))) ctx)
                #t
                #f)
            #f))
      #f)
  )
(define (judger? exp)
  (or (tagged-list? exp 'eq?)
      (tagged-list? exp 'null?)
      (tagged-list? exp 'number?)
      (tagged-list? exp 'pair?)
      (tagged-list? exp 'equal?)
      (tagged-list? exp 'symbol?)
      (tagged-list? exp 'display)
      (tagged-list? exp 'displayln)))

(define (set-something-inside-type? exp ctx)
  (if (not (pair? (car exp)))
      (let ((first (find-first-not- (symbol->string (car exp)) 0)))
        (if (and first (> first 0) (> (string-length (symbol->string (car exp))) (+ 5 first)) (equal? (string->symbol(substring (symbol->string (car exp)) first (+ first 6))) '-set!- ))
            (if (constructor? (list (string->symbol(substring (symbol->string (car exp)) 0 first))) ctx)
                #t
                #f)
            #f))
      #f)
  )

(define (condition? exp)
  (or (tagged-list? exp 'and) (tagged-list? exp 'or)))

(define (true-false? exp)
  (or (equal? exp 'true) (equal? exp 'false)))

(define (append? exp)
  (tagged-list? exp 'append))

(define (application? exp) (pair? exp))

(define (string-replace? exp) (tagged-list? exp 'string-replace))

(define (template-struct? exp) (tagged-list? exp 'define-template-struct))

(define (template-function? exp) (tagged-list? exp 'define-template-function))

(define (typechecker type ctx)
  (define (innerloop types new-ctx)
    (cond ((null? types) (if(null? (cadddr new-ctx))
                            (error "type not found" type)
                            (innerloop (caddr (cadddr new-ctx)) (cadddr new-ctx))))
          ((equal? type (car (car types))) #t)
          (else (innerloop (cdr types) new-ctx))))
  (if(or (equal? type 'string) (equal? type 'number) (equal? type 'boolean)(equal? type 'void))
     #t
     (innerloop (caddr ctx) ctx)))


(define (template-typechecker type ctx)
  (define (innerloop types new-ctx)
    (cond ((null? types) (if(null? (cadddr new-ctx))
                            (error "type not found" type)
                            (innerloop (caddr (cadddr new-ctx)) (cadddr new-ctx))))
          ((equal? type (car (car types)))
           (if (tagged-list? (cadr (car types)) 'template)
                                               (error "template without parameters, template type:" type)
                                               #t))
          (else (innerloop (cdr types) new-ctx))))
  (if(or (equal? type 'string) (equal? type 'number) (equal? type 'boolean)(equal? type 'void))
     #t
     (innerloop (caddr ctx) ctx)))

(define (typelistchecker typelist ctx)
  (cond ((null? typelist) #t)
        ((tagged-list? (car typelist) 'function) (begin (typelistchecker (cadr (car typelist)) ctx)
                                                        (typelistchecker (list (caddr (car typelist))) ctx)
                                                        (typelistchecker (cdr typelist) ctx)))
        ((tagged-list? (car typelist) 'template) (begin (typelistchecker (cadr (car typelist)) ctx)
                                                        (typechecker (caddr (car typelist)) ctx)
                                                        (typelistchecker (cdr typelist) ctx)))
        ((not (pair? (car typelist))) (begin (template-typechecker (car typelist) ctx)
                                             (typelistchecker (cdr typelist) ctx)))
        (else (begin (for-each (lambda (type) (template-typechecker type ctx)) (car typelist))
                     (typelistchecker (cdr typelist) ctx)))))
        
(define (typeof exp ctx)
  (cond ((eq? exp '()) 'void)
        ((number? exp) 'number)
        ((string? exp) 'string)
        ((boolean? exp) 'boolean)
        ((true-false? exp) 'boolean)
        ((equal? exp 'void) 'void)
        ((equal? exp '(void)) 'void)
        ((list-exp? exp) (typeof-list exp ctx))
        ((assignment? exp) (typeof-assignment exp ctx))
        ((template-struct? exp) (typeof-template-struct exp ctx))
        ((template-function? exp) (typeof-template-function exp ctx))
        ((primitive? exp) (typeof-primitive exp ctx))
        ((format? exp) (typeof-format exp ctx))
        ((string-replace? exp)(typeof-string-replace exp ctx))
        ((define-struct? exp) (typeof-define-struct exp ctx))
        ((variable? exp) (typeof-variable exp ctx))
        ((define? exp) (typeof-define exp ctx))
        ((condition? exp) (typeof-condition exp ctx))
        ((if? exp) (typeof-if exp ctx))
        ((judger? exp) (typeof-judger exp ctx))
        ((append? exp) (typeof-append exp ctx))
        ((cons-exp? exp) (typeof-cons exp ctx))
        ((car? exp) (typeof-car exp ctx))
        ((cdr? exp) (typeof-cdr exp ctx))
        ((not? exp) (typeof-not exp ctx))
        ((let? exp) (typeof-let exp ctx))
        ((cond? exp) (typeof-cond exp ctx))
        ((begin? exp) (typeof-begin exp ctx))
        ((get-something-from-type? exp ctx) (typeof-get-type exp ctx))
        ((set-something-inside-type? exp ctx) (typeof-set-type exp ctx))
        ((constructor? exp ctx) (typeof-constructor exp ctx))
        ((lambda? exp) (typeof-lambda exp ctx))
        ((application? exp) (typeof-application exp ctx))
        (else
         (error "unknown expression type -- TYPE" exp))))

(define (typeof-define exp ctx)
  (define (innerloop vars types variable-name body new-ctx)
    (cond ((null? vars) (let ((new-type (typeof body new-ctx)))
                          (typelistchecker (list new-type) ctx)
                               (set-car! ctx (cons variable-name (car ctx)))
                               (set-car! (cdr ctx) (cons new-type (cadr ctx)))
                               'void))
          ((equal? (car vars) variable-name) (let ((new-type (typeof body new-ctx)))
                                         (if (equal? new-type (car types))
                                             'void
                                             (begin (set-car! types new-type)
                                                    'void))))
          (else (innerloop (cdr vars) (cdr types) variable-name body new-ctx))))
  (if (pair? (cadr exp))
      (innerloop (car ctx) (cadr ctx) (caadr exp) (cons 'lambda (cons (cdadr exp) (cddr exp))) (list (list (caadr exp)) (list (list 'function (map cadr (cdadr exp)) (caddr exp))) '() ctx ))
      (innerloop (car ctx) (cadr ctx) (cadr exp) (caddr exp) ctx)))

(define (typeof-template-function exp ctx)
  (define function-env (list '() '() '() ctx))
  (define (innerloop templates)
    (cond ((null? templates) (void))
          (else (begin (typeof `(define-struct ,(car templates)) function-env)
                       (innerloop (cdr templates))))))
  (define (innerloop2 vars types variable-name new-type)
    (cond ((null? vars) (begin
                              (set-car! ctx (cons variable-name (car ctx)))
                              (set-car! (cdr ctx) (cons new-type (cadr ctx)))
                              'void))
          ((equal? (car vars) variable-name) 
                                         (if (equal? new-type (car types))
                                             'void
                                             (error "newly-defined variable doesn't have the same type as before." " new-type:" new-type " old-type:" (car types))))
          (else (innerloop2 (cdr vars) (cdr types) variable-name new-type))))
  
  (innerloop (cadr exp))
  (let ((ft (typeof (cons 'lambda (cons (cdaddr exp) (cdddr exp)))  (list (list (caaddr exp)) (list (list 'template (cadr exp) (list 'function (map cadr (cdaddr exp)) (cadddr exp)))) '() function-env ))))
    (typelistchecker (list ft) function-env)
    (let ((function-type (list 'template (cadr exp) ft)))
      (innerloop2 (car ctx) (cadr ctx) (caaddr exp) function-type)
      )))

(define (typeof-car exp ctx)
  (let ((type (typeof (cadr exp) ctx)))
    (if (and (tagged-list? type 'template) (equal? (caddr type) 'list))
        (car (cadr type))
        (error" car apply on a nonlist type" exp))))

(define (typeof-not exp ctx)
  (let ((type (typeof (cadr exp) ctx)))
    (if (equal? type 'boolean)
        'boolean
        (error "not apply on a non-boolean type:" type exp)))) 


(define (typeof-cdr exp ctx)
  (let ((type (typeof (cadr exp) ctx)))
    (if (and (tagged-list? type 'template) (equal? (caddr type) 'list))
        type
        (error" car apply on a nonlist type" exp))))

(define (typeof-cons exp ctx)
  (let ((car-type (typeof (cadr exp) ctx))
        (cdr-type (typeof (caddr exp) ctx)))
    (if (and (tagged-list? cdr-type 'template) (equal? (caddr cdr-type) 'list) (= (length (cadr cdr-type))1) (equal? car-type (car (cadr cdr-type))))
        cdr-type
        (error "cons expression parameter not matched" exp))))
(define (typeof-assignment exp ctx)
  (if (symbol? (cadr exp))
      (let ((type1 (typeof (cadr exp) ctx))(type2 (typeof (caddr exp) ctx)))
        (if (equal? type1 type2)
            'void
            (error "assignment type doesn't match with the original type. original type:" type1 "new type:" type2 "expression:" exp)))
      (error "try to assign something isn't a variable" exp)))

(define (typeof-variable exp ctx)
  (define (innerloop vars types new-ctx)
    (cond ((null? vars) (if (null? (cadddr new-ctx))
                            (error "variable not found" (cadr exp))
                            (innerloop (car (cadddr new-ctx)) (cadr (cadddr new-ctx)) (cadddr new-ctx))))
          ((equal? exp (car vars)) (car types))
          (else (innerloop (cdr vars) (cdr types) new-ctx))))
  (innerloop (car ctx) (cadr ctx) ctx))

(define (typeof-if exp ctx)
  (if (equal? (typeof (cadr exp) ctx) 'boolean)
      (let ((type1 (typeof(caddr exp) ctx)) (type2 (typeof(cadddr exp) ctx)))
        (if (equal? type1 type2)
            type1
            (error "type not match in if-expression" (caddr exp) type1 (cadddr exp) type2)))
      (error "judgement of if isn't a boolean" (cadr exp))))
(define (typeof-append exp ctx)
  (define (judging rest type)
    (cond ((null? rest) #t)
          ((equal? (typeof (car rest) ctx) type) (judging (cdr rest) type))
          (else (error "append different things" exp))))
    (if (< (length exp) 2)
      (error "append nothing")
      (let ((type (typeof (cadr exp) ctx)))
        (if (and (tagged-list? type 'template) (equal? (caddr type) 'list))
            (begin (judging (cddr exp) type)
                   type)
            (error "try to append somthing isn't a list" exp) ))))

(define (typeof-list exp ctx)
  (define (innerloop expression type)
    (cond((null? expression)(cons 'template (cons (list type) (cons 'list '()))))
         ((equal? (typeof (car expression) ctx) type) (innerloop (cdr expression) type))
         (else (error "expression inside the list doesn't match with the list type" (car expression) type))))
  (typelistchecker (cadr exp) ctx)
  (if (= (length (cadr exp)) 1)
      (innerloop (cddr exp) (car (cadr exp)))
      (error "more than one type inside the list template")))

(define (typeof-cond exp ctx)
  (define (judging type cond-body)
    (cond ((null? cond-body) type)
          ((equal? (car (car cond-body)) 'else) (if (equal? (typeof-sequence (cdar cond-body) ctx) type)
                                                 type
                                                 (error "return type in cond-clauses not matched" exp)))
          ((equal? (typeof (car (car cond-body)) ctx) 'boolean)(if (equal? (typeof-sequence (cdar cond-body) ctx) type)
                                                 type
                                                 (error "return type in cond-clauses not matched" exp)))
          (else (error "judge type in cond-clauses not matched" exp))))
  (judging (typeof-sequence (cdadr exp) ctx) (cdr exp)))

(define (typeof-sequence exp ctx)
  (cond ((null? exp)  'void)
        ((null? (cdr exp)) (typeof (car exp) ctx))
        (else (begin (typeof (car exp) ctx)
                     (typeof-sequence (cdr exp) ctx)
  ))))

(define (typeof-lambda exp ctx)
   (let ((type (typeof-sequence (cdddr exp) (list (map car (cadr exp)) (map cadr (cadr exp)) '() ctx))))
    (if(equal? (caddr exp) 'auto)
       (list 'function (map cadr (cadr exp)) type)
     (if (equal? type (caddr exp))
        (list 'function (map cadr (cadr exp)) type)
        (error "return type doesn't match with the declaration" exp)))))

(define (typeof-string-replace exp ctx)
  (if (and (= (length exp) 4) (equal? (typeof (cadr exp) ctx) 'string) (equal? (typeof (caddr exp) ctx) 'string) (equal? (typeof (cadddr exp) ctx) 'string))
      'string
      (error "string-replace parameters not matched" exp)))

(define (typeof-format exp ctx)
  (if (>= (length exp) 2)
      (begin (for-each (lambda (x) (typeof x ctx)) (cddr exp))
             (if (equal? (typeof (cadr exp) ctx) 'string)
                 'string
                 (error "format on a non-string-type")))
      (error "parameter not matched in string")))
(define (typeof-primitive exp ctx)
  (define (judging body)
    (cond ((null? body) #t)
          ((equal? (typeof (car body) ctx) 'number) (judging (cdr body)))
          (else #f)))
  (if (judging (cdr exp))
      (if (> (length (cdr exp)) 1)
          (if (or (equal? (car exp) '+)
                  (equal? (car exp) 'remainder)
                  (equal? (car exp) '-)
                  (equal? (car exp) '*)
                  (equal? (car exp) '/))
              'number
              'boolean)
          (error "parameter length is less than 2" exp))
      (error "parameter isn't all number" exp)))
(define (list-of-type types ctx)
  (cond ((null? types) '())
        (else (cons (typeof (car types) ctx) (list-of-type (cdr types) ctx)))))

(define (typeof-begin exp ctx)
  (typeof-sequence (cdr exp) ctx))

(define (traverse exp templates types)
  (define (innerloop new-exp template type)
    (cond ((null? new-exp) new-exp)
          ((pair? new-exp) (cons (innerloop (car new-exp) template type) (innerloop (cdr new-exp) template type)))
          ((equal? new-exp template) type)
          (else new-exp)))
  (define (outerloop new-exp new-templates new-types)
    (cond ((null? new-templates) new-exp)
          (else (outerloop (innerloop new-exp (car new-templates) (car new-types)) (cdr new-templates) (cdr new-types)))))
  (outerloop exp templates types))

(define (typeof-application exp ctx)
  (let ((function-type (typeof (car exp) ctx)))
    (if (tagged-list? function-type 'template)
        (if (= (length (cadr function-type)) (length (cadr exp)))
            (let ((parameter-types (list-of-type (cddr exp) ctx))(new-function-type (traverse (caddr function-type) (cadr function-type) (cadr exp))))
              (typelistchecker (cadr exp) ctx)
              (cond ((and (pair? new-function-type)(not (equal? (car new-function-type) 'function))) (error "parameters don't apply on a function, function type:" new-function-type))
                    ((and (pair? new-function-type) (equal? (cadr new-function-type) parameter-types))(caddr new-function-type))
                    (else (error "parameter doesn't match with the function" new-function-type parameter-types))))
            (error "template parameters not matched" function-type (cadr exp)))
        (let ((parameter-types (list-of-type (cdr exp) ctx)))
          (cond ((and (pair? function-type)(not (equal? (car function-type) 'function))) (error "parameters don't apply on a function, function type:" function-type))
                ((and (pair? function-type) (equal? (cadr function-type) parameter-types))(caddr function-type))
                (else (error "parameter doesn't match with the function" function-type parameter-types)))
  ))))

(define (typeof-let exp ctx)
  (typeof-sequence (cddr exp) (list (map car (cadr exp)) (map (lambda (expression) (typeof (cadr expression) ctx)) (cadr exp)) '() ctx)
  ))

(define (typeof-define-struct exp ctx)
  (define struct-env (list '() '() '() ctx))
  (define (innerloop body)
    (if (null? body)
        (begin (set-car! (cddr ctx) (cons (list (cadr exp) struct-env) (caddr ctx)))
               'void)
        (if (define? (car body))
            (begin (typeof (car body) struct-env)
                   (innerloop (cdr body)))
            (error "definition inside the define-struct isn't a definition" (car body) exp))))
  (innerloop (cddr exp)))
(define (typeof-judger exp ctx)
  (cond ((and (= (length exp) 3) (or (tagged-list? exp 'equal?) (tagged-list? exp 'eq?))) (begin (typeof (cadr exp) ctx)
                                                                                                 (typeof (caddr exp) ctx)
                                                                                                 'boolean))
        ((= (length exp) 2)(begin (typeof (cadr exp) ctx)
                                  (if (or (tagged-list? exp 'display) (tagged-list? exp 'displayln))
                                      'void
                                      'boolean)))
        (else (error "parameter not matched in" exp))))
(define (typeof-template-struct exp ctx)
  (define struct-env (list '() '() '() ctx))
  (define (finder type rest)
    (cond ((null? rest)#f)
          ((equal? (car rest) type) #t)
          (else (finder type (cdr rest)))))
  (define (preprocessing rest)
    (cond ((null? rest) '())
          ((pair? (caddr (car rest))) (if (and (= (length (caddr (car rest))) 1) (finder (car (caddr (car rest))) (cadr exp)))
                                          (error "template haven't been instantiated" (car (caddr (car rest))))
                                          (cons (car rest) (preprocessing (cdr rest)))))
          (else (if (finder (caddr (car rest)) (cadr exp))
                    (cons (cons (car (car rest)) (cons (cadr (car rest)) (cons (list (caddr (car rest))) '()))) (preprocessing (cdr rest)))
                    (cons (car rest) (preprocessing (cdr rest)))))))
  (define (innerloop templates)
    (cond ((null? templates)(void))
          (else (begin (typeof `(define-struct ,(car templates)) struct-env)
                       (innerloop (cdr templates))))))
  (innerloop (cadr exp))
  (typeof (cons 'define-struct (cons (caddr exp) (preprocessing (cdddr exp)))) struct-env)
  (set-car! (cdddr (cadr (car (caddr struct-env)))) '())
  (set-car! (cddr ctx) (cons (list (caddr exp) (list 'template (cadr exp))
                                   (cadr (car (caddr struct-env)))) (caddr ctx)))
  'void)


(define (typeof-constructor exp ctx)
  (define (innerloop body new-ctx)
    (cond ((null? body)(innerloop (caddr(cadddr new-ctx))(cadddr new-ctx)))
          ((equal? (car exp) (car (car body))) (car body))
          (else (innerloop (cdr body) new-ctx))))
  (define (checkloop parameter type variables types)
   (cond ((null? variables) (error "parameter in the constructor not found" parameter exp))
         ((equal? parameter (car variables)) (if (equal? type (car types))
                                                 #t
                                                 (error "parameter type doesn't match with the variable defined inside the struct.new type: " type "old type:" (car types) "parameter:"parameter)))
         (else (checkloop parameter type (cdr variables) (cdr types)))))
  (let ((struct-info (innerloop (caddr ctx) ctx)))
    (if (tagged-list? (cadr struct-info) 'template)
        (if (and (= (length (cadr (cadr struct-info))) (length (cadr exp))) (typelistchecker (cadr exp) ctx))
            (let ((struct-env (traverse (caddr struct-info) (cadr (cadr struct-info)) (cadr exp))))
          (begin (for-each (lambda (parameters)
                       (if (variable? (car parameters))
                           (checkloop (car parameters) (typeof (cadr parameters) ctx) (car struct-env) (cadr struct-env))
                           (error "parameter inside the constructor isn't a variable" parameters)))
                     (cddr exp))
           (list 'template (cadr exp) (car exp))))
            (error "length of template parameters not matched" (cadr (cadr struct-info)) (cadr exp))
            )
        (let ((struct-env (cadr struct-info)))
          (begin (for-each (lambda (parameters)
                       (if (variable? (car parameters))
                           (checkloop (car parameters) (typeof (cadr parameters) ctx) (car struct-env) (cadr struct-env))
                           (error "parameter inside the constructor isn't a variable" parameters)))
                     (cdr exp))
           (car exp))))))

(define (typeof-get-type exp ctx)
  (define (innerloop body new-ctx type)
    (cond ((null? body)(innerloop (caddr(cadddr new-ctx))(cadddr new-ctx) type))
          ((equal? type (car (car body))) (car body))
          (else (innerloop (cdr body) new-ctx type))))
  (let ((first (find-first-not- (symbol->string (car exp)) 0)))
    (let ((type (string->symbol (substring (symbol->string (car exp)) 0 first )))
          (variable (string->symbol (substring (symbol->string (car exp)) (+ first 5)))))
      (let ((struct-info (innerloop (caddr ctx) ctx type)))
        (if (tagged-list? (cadr struct-info) 'template)
            (let ((template-type (typeof (cadr exp) ctx)))
            (if (equal? type (caddr template-type))
                (let ((return-type (typeof variable  (list (car (caddr struct-info)) (cadr (caddr struct-info)) (caddr (caddr struct-info)) '()))))
                  (traverse return-type (cadr (cadr struct-info))(cadr template-type))) 
                (error "try to get something from another type" exp "target-type:" (typeof (cadr exp) ctx))))
            (if (equal? type (typeof (cadr exp) ctx))
                (let ((return-type (typeof variable  (list (car (cadr struct-info)) (cadr (cadr struct-info)) (caddr (cadr struct-info)) '()))))
                  return-type)
                (error "try to get something from another type" exp "target-type:" (typeof (cadr exp) ctx))))))))

(define (typeof-set-type exp ctx)
  (define (innerloop body new-ctx type)
    (cond ((null? body)(innerloop (caddr(cadddr new-ctx))(cadddr new-ctx) type))
          ((equal? type (car (car body))) (car body))
          (else (innerloop (cdr body) new-ctx type))))
  (let ((first (find-first-not- (symbol->string (car exp)) 0)))
    (let ((type (string->symbol (substring (symbol->string (car exp)) 0 first )))
          (variable (string->symbol (substring (symbol->string (car exp)) (+ first 6))))
          (new-type (typeof (caddr exp) ctx)))
      (let ((struct-info (innerloop (caddr ctx) ctx type)))
        (if (tagged-list? (cadr struct-info) 'template)
            (let ((template-type (typeof (cadr exp) ctx)))
              (if (equal? type (caddr template-type))
                  (let ((variable-type (typeof variable  (list (car (caddr struct-info)) (cadr (caddr struct-info)) (caddr (caddr struct-info)) '()))))
                    (if(equal? (traverse variable-type (cadr (cadr struct-info))(cadr template-type)) new-type)
                       template-type
                       (error "try to set something of another type inside the struct.new type:"new-type "old type:"variable-type exp))) 
                  (error "try to get something from another type" exp "target-type:" (typeof (cadr exp) ctx))))
            (if (equal? type (typeof (cadr exp) ctx))
                (let ((variable-type (typeof variable  (list (car (cadr struct-info)) (cadr (cadr struct-info)) (caddr (cadr struct-info)) '()))))
                  (if (equal? variable-type new-type)
                      type
                      (error "try to set something of another type inside the struct.new type:"new-type "old type:"variable-type exp)))
                (error "try to set something inside another type" exp "target-type:" (typeof (cadr exp) ctx))))))))

(define (typeof-condition exp ctx)
  (define (innerloop body)
    (cond ((null? body) 'boolean)
          ((equal? (typeof (car body) ctx) 'boolean) (innerloop (cdr body)))
          (else (error "expression in the and/or expression is not a boolean type" exp (car body)))))
  (if (< (length exp) 3)
      (error "expression length in the and/or expression is less than 2" exp)
      (innerloop (cdr exp))))

(define glb-ctx (list '() '() '() '()))
(typeof '(define-template-struct (T) list) glb-ctx)
 

(define (loop)
  (let ((a (read)))
    (if (eq? a eof)
        (void)
        (begin (display (typeof a glb-ctx))
               (newline)
               (loop)))))
(loop)